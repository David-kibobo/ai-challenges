diff --git a/package.json b/package.json
index 16c7979d..6c5bb005 100644
--- a/package.json
+++ b/package.json
@@ -285,6 +285,7 @@
     "eslint": "^9.39.1",
     "eslint-config-prettier": "^10.1.8",
     "eslint-plugin-prettier": "^5.5.4",
+    "eventsource": "^4.1.0",
     "express": "^5.1.0",
     "fastify": "^5.6.2",
     "fs-teardown": "^0.3.0",
@@ -328,4 +329,4 @@
     "prepare-commit-msg": "grep -qE '^[^#]' .git/COMMIT_EDITMSG || (exec < /dev/tty && pnpm cz --hook || true)",
     "commit-msg": "pnpm commitlint --edit $1"
   }
-}
+}
\ No newline at end of file
diff --git a/test.sh b/test.sh
new file mode 100755
index 00000000..6dfd126b
--- /dev/null
+++ b/test.sh
@@ -0,0 +1,48 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+# Determine mode
+if [ "$#" -ge 1 ]; then
+  MODE="$1"
+elif [ "${MODE-""}" != "" ]; then
+  MODE="$MODE"
+else
+  MODE=base
+fi
+
+echo "Running tests (mode: ${MODE})"
+
+
+EXCLUDES=(
+  "third-party/axios-error-response.test.ts"
+  "third-party/axios-upload.node.test.ts"
+  "msw-api/setup-server/resetHandlers.node.test.ts"
+  "msw-api/setup-server/scenarios/fall-through.node.test.ts"
+  "msw-api/setup-server/scenarios/on-unhandled-request/callback.node.test.ts"
+  "msw-api/setup-server/scenarios/on-unhandled-request/default.node.test.ts"
+)
+
+
+EXCLUDE_ARGS=()
+for pat in "${EXCLUDES[@]}"; do
+  EXCLUDE_ARGS+=( "--exclude=${pat}" )
+done
+
+if [ "${MODE}" = "base" ]; then
+  echo "Running base tests"
+  pnpm -s build
+
+
+  pnpm -s vitest --run --config=./test/node/vitest.config.ts "${EXCLUDE_ARGS[@]}"
+  exit 0
+fi
+
+if [ "${MODE}" = "new" ]; then
+  echo "Running experimental tests"
+    pnpm -s build
+  pnpm -s vitest --run --config=./test/cleanup-tests/vitest.config.ts || exit 1
+  exit 0
+fi
+
+echo "Unknown MODE: ${MODE}. Use MODE=base or MODE=new"
+exit 2
diff --git a/test/cleanup-tests/setup-sse.ts b/test/cleanup-tests/setup-sse.ts
new file mode 100644
index 00000000..fd5eaf62
--- /dev/null
+++ b/test/cleanup-tests/setup-sse.ts
@@ -0,0 +1,16 @@
+// test/setup-sse.ts
+
+import { EventSource } from 'eventsource'
+import { fetch, Headers, Request, Response } from 'undici'
+
+  ; (globalThis as any).EventSource = EventSource;
+; (global as any).EventSource = EventSource;
+
+if (typeof globalThis.fetch === 'undefined') {
+  ; (globalThis as any).fetch = fetch as any
+    ; (globalThis as any).Headers = Headers
+    ; (globalThis as any).Request = Request
+    ; (globalThis as any).Response = Response
+}
+
+console.log('[setup-sse] EventSource polyfilled with "eventsource" package.') 
\ No newline at end of file
diff --git a/test/cleanup-tests/sse/sse-test-cleanup.test.ts b/test/cleanup-tests/sse/sse-test-cleanup.test.ts
new file mode 100644
index 00000000..2102eb5b
--- /dev/null
+++ b/test/cleanup-tests/sse/sse-test-cleanup.test.ts
@@ -0,0 +1,299 @@
+
+// test/cleanup-tests/sse/sse-handler-matching.node.test.ts
+
+import { setupServer } from 'msw/node';
+import { sse } from 'msw';
+import { test, expect, describe, beforeAll, afterAll, beforeEach, afterEach } from 'vitest';
+
+
+const STREAM_URL = 'http://localhost/stream';
+const MESSAGE_RECEIVE_TIMEOUT = 1000;
+
+
+
+const path = require('path');
+const SOLVER_PATH = path.resolve(__dirname, '../../../src/core/utils/msw-sse-tools');
+
+
+
+console.info(`[Test Setup] Looking for solver implementation at: ${SOLVER_PATH}`);
+
+
+interface TestMswSseHandlerReturn {
+  mswSseHandler: ({ client, request }: { client: any, request: Request }) => Promise<void>;
+  getActiveHandlerPromises: () => Promise<void>[];
+}
+
+
+let createTestMswSseHandlerFactory: (options?: { leaseTimeoutMs?: number }) => TestMswSseHandlerReturn;
+
+
+try {
+  // eslint-disable-next-line @typescript-eslint/no-var-requires
+  const solverModule = await import(SOLVER_PATH);
+
+
+
+  if (solverModule.createSseClientTracker) {
+    console.info("✅ Solver implementation found. Using their solution.");
+
+    createTestMswSseHandlerFactory = (options) => {
+      const connectionTracker = new Map<string, Promise<void>>();
+
+      const mswSseHandler = async ({ client, request }: { client: any, request: Request }) => {
+
+        const tracker = solverModule.createSseClientTracker(client, request, options?.leaseTimeoutMs);
+        const connectionId = tracker.connectionId;
+
+        let messageInterval: NodeJS.Timeout | null = null;
+
+        connectionTracker.set(client.id || String(connectionId), tracker.keepAlivePromise);
+
+        const handleCleanup = () => {
+          if (messageInterval) {
+            clearInterval(messageInterval);
+            messageInterval = null;
+          }
+          connectionTracker.delete(client.id || String(connectionId));
+        };
+
+        tracker.onClose(handleCleanup);
+
+        messageInterval = setInterval(() => {
+          try {
+
+            client.send({ event: 'message', data: `TEST_MSG:${connectionId}:${Date.now()}` });
+          } catch (err: any) {
+            tracker.emitClose('data-send-failed');
+          }
+        }, 100);
+
+        await tracker.keepAlivePromise;
+
+        if (messageInterval) { clearInterval(messageInterval); }
+      };
+
+      return {
+        mswSseHandler,
+        getActiveHandlerPromises: () => Array.from(connectionTracker.values()),
+      };
+    };
+  } else {
+    throw new Error("Module found but export missing");
+  }
+
+} catch (error) {
+  console.warn("⚠️ Solver implementation NOT found. Using BUGGY implementation to fail tests intentionally.");
+
+
+  createTestMswSseHandlerFactory = () => {
+    const leakedPromises: Promise<void>[] = [];
+
+    const mswSseHandler = async ({ client }: { client: any }) => {
+
+      const leakyPromise = new Promise<void>(() => { });
+      leakedPromises.push(leakyPromise);
+
+      console.log(`[Buggy Handler] Client connected. Starting eternal interval...`);
+
+
+      setInterval(() => {
+        try {
+          client.send({ event: 'message', data: 'leaking...' });
+        } catch (e) { }
+      }, 100);
+
+      await leakyPromise;
+    };
+
+    return {
+      mswSseHandler,
+
+      getActiveHandlerPromises: () => leakedPromises
+    };
+  };
+}
+
+
+
+try {
+  if (typeof (globalThis as any).EventSource === 'undefined') {
+    const EventSourcePkg = require('eventsource');
+    (globalThis as any).EventSource = EventSourcePkg;
+  }
+} catch (error) { console.error('Failed to load eventsource polyfill', error); }
+
+function until<T>(predicate: () => T | undefined | null, timeout = 2000, interval = 10) {
+  return new Promise<T>((resolve, reject) => {
+    const deadline = Date.now() + timeout;
+    const loop = () => {
+      const val = predicate();
+      if (val !== undefined && val !== null) { resolve(val); return; }
+      if (Date.now() > deadline) { reject(new Error('timeout waiting for condition')); return; }
+      setTimeout(loop, interval);
+    };
+    loop();
+  });
+}
+
+
+describe(`msw-sse-tools: API cleanup behavior`, () => {
+  let server: ReturnType<typeof setupServer>;
+  const receivedMessages: Record<string, { msg: string; t: number }[]> = {};
+
+  let handlerFactory: TestMswSseHandlerReturn;
+  let activeEventSources: EventSource[] = [];
+
+  beforeAll(() => {
+    server = setupServer();
+    server.listen({ onUnhandledRequest: 'bypass' });
+  });
+
+  afterAll(() => {
+    server.close();
+  });
+
+  beforeEach(() => {
+    Object.keys(receivedMessages).forEach(key => delete receivedMessages[key]);
+    server.resetHandlers();
+    activeEventSources = [];
+
+    // Create the factory (Buggy or Solved)
+    handlerFactory = createTestMswSseHandlerFactory();
+    server.use(sse(STREAM_URL, handlerFactory.mswSseHandler) as any);
+  });
+
+  afterEach(() => {
+    activeEventSources.forEach(es => {
+      if (es.readyState !== EventSource.CLOSED) es.close();
+    });
+  });
+
+  test('single client disconnects gracefully after explicit close', async () => {
+    const clientLabel = 'Client1';
+    receivedMessages[clientLabel] = [];
+    const es = new EventSource(STREAM_URL);
+    activeEventSources.push(es);
+
+    es.addEventListener('message', (e: any) => {
+
+      if (receivedMessages[clientLabel]) {
+        receivedMessages[clientLabel].push({ msg: String(e.data), t: Date.now() });
+      }
+    });
+
+
+    await until(() => receivedMessages[clientLabel]?.length > 0 ? true : null, MESSAGE_RECEIVE_TIMEOUT);
+
+    await until(() => handlerFactory.getActiveHandlerPromises().length === 1 ? true : null, MESSAGE_RECEIVE_TIMEOUT);
+
+    es.close();
+
+
+    const promisesToAwait = handlerFactory.getActiveHandlerPromises();
+
+    await Promise.race([
+      Promise.allSettled(promisesToAwait),
+      new Promise(r => setTimeout(r, 500))
+    ]);
+
+
+    expect(handlerFactory.getActiveHandlerPromises().length, 'No active handler promises after client disconnects.').toBe(0);
+  }, 15000);
+
+  test('multiple clients disconnect gracefully under stress', async () => {
+    const NUM_CLIENTS = 10;
+    for (let i = 0; i < NUM_CLIENTS; i++) {
+      const clientLabel = `Client${i}`;
+      receivedMessages[clientLabel] = [];
+      const es = new EventSource(STREAM_URL);
+      activeEventSources.push(es);
+      es.addEventListener('message', (e: any) => {
+        if (receivedMessages[clientLabel]) {
+          receivedMessages[clientLabel].push({ msg: String(e.data), t: Date.now() });
+        }
+      });
+      await new Promise((r) => setTimeout(r, 10));
+    }
+
+    await Promise.all(Array.from({ length: NUM_CLIENTS }).map((_, i) =>
+      until(() => receivedMessages[`Client${i}`]?.length > 0 ? true : null, MESSAGE_RECEIVE_TIMEOUT * 2)
+    ));
+
+    await until(() => handlerFactory.getActiveHandlerPromises().length === NUM_CLIENTS ? true : null, MESSAGE_RECEIVE_TIMEOUT);
+
+    activeEventSources.forEach(es => es.close());
+
+    await new Promise(r => setTimeout(r, 500));
+
+
+    expect(handlerFactory.getActiveHandlerPromises().length, 'All handlers should be cleaned up.').toBe(0);
+  }, 30000);
+
+  test('new handler instance is isolated after previous clients disconnect', async () => {
+    const clientLabel1 = 'InitialClient';
+    receivedMessages[clientLabel1] = [];
+    const es1 = new EventSource(STREAM_URL);
+    activeEventSources.push(es1);
+    es1.addEventListener('message', (e: any) => {
+      if (receivedMessages[clientLabel1]) receivedMessages[clientLabel1].push({ msg: String(e.data), t: Date.now() });
+    });
+
+    await until(() => receivedMessages[clientLabel1]?.length > 0 ? true : null, MESSAGE_RECEIVE_TIMEOUT);
+    await until(() => handlerFactory.getActiveHandlerPromises().length === 1 ? true : null, MESSAGE_RECEIVE_TIMEOUT);
+
+    es1.close();
+    await new Promise(r => setTimeout(r, 200));
+
+    expect(handlerFactory.getActiveHandlerPromises().length, 'Initial client cleaned up.').toBe(0);
+
+    handlerFactory = createTestMswSseHandlerFactory();
+    server.use(sse(STREAM_URL, handlerFactory.mswSseHandler) as any);
+
+    const clientLabel2 = 'NewClient';
+    receivedMessages[clientLabel2] = [];
+    const es2 = new EventSource(STREAM_URL);
+    activeEventSources.push(es2);
+    es2.addEventListener('message', (e: any) => {
+      if (receivedMessages[clientLabel2]) receivedMessages[clientLabel2].push({ msg: String(e.data), t: Date.now() });
+    });
+
+    await until(() => receivedMessages[clientLabel2]?.length > 0 ? true : null, MESSAGE_RECEIVE_TIMEOUT);
+
+    expect(handlerFactory.getActiveHandlerPromises().length, 'New handler factory tracks new client correctly.').toBe(1);
+
+    es2.close();
+    await new Promise(r => setTimeout(r, 200));
+    expect(handlerFactory.getActiveHandlerPromises().length, 'New client cleaned up.').toBe(0);
+  }, 25000);
+
+  test('ping mechanism keeps session alive beyond lease timeout', async () => {
+
+    const SHORT_LEASE_TIMEOUT_MS = 600;
+    handlerFactory = createTestMswSseHandlerFactory({ leaseTimeoutMs: SHORT_LEASE_TIMEOUT_MS });
+    server.use(sse(STREAM_URL, handlerFactory.mswSseHandler) as any);
+
+    const clientLabel = 'ShortLeaseClient';
+    receivedMessages[clientLabel] = [];
+    const es = new EventSource(STREAM_URL);
+    activeEventSources.push(es);
+    es.addEventListener('message', (e: any) => {
+      if (receivedMessages[clientLabel]) receivedMessages[clientLabel].push({ msg: String(e.data), t: Date.now() });
+    });
+
+    await until(() => receivedMessages[clientLabel]?.length > 0 ? true : null, MESSAGE_RECEIVE_TIMEOUT);
+
+
+    await new Promise(r => setTimeout(r, SHORT_LEASE_TIMEOUT_MS + 400));
+
+
+    expect(handlerFactory.getActiveHandlerPromises().length, 'Handler should remain active.').toBe(1);
+    expect(es.readyState, 'EventSource should still be OPEN.').toBe(EventSource.OPEN);
+
+    es.close();
+    await new Promise(r => setTimeout(r, 200));
+
+
+    expect(handlerFactory.getActiveHandlerPromises().length, 'Handler cleaned up after explicit close.').toBe(0);
+  }, 10000);
+});
\ No newline at end of file
diff --git a/test/cleanup-tests/vitest.config.ts b/test/cleanup-tests/vitest.config.ts
new file mode 100644
index 00000000..df24fe4a
--- /dev/null
+++ b/test/cleanup-tests/vitest.config.ts
@@ -0,0 +1,14 @@
+// test/cleanup-tests/vitest.config.ts 
+import { defineConfig } from 'vitest/config';
+import path from 'path'; // Assume path is imported
+
+export default defineConfig({
+  test: {
+    dir: './test/cleanup-tests',
+    globals: true,
+    environment: 'node',
+    // CORRECTED PATH: Use './setup-sse.ts' as it is relative to __dirname
+    setupFiles: [path.resolve(__dirname, './setup-sse.ts')],
+    testTimeout: 20000,
+  },
+});
\ No newline at end of file
