diff --git a/package.json b/package.json
index e19e9d6b..17855536 100644
--- a/package.json
+++ b/package.json
@@ -310,6 +310,7 @@
     "url-loader": "^4.1.1",
     "vitest": "^3.2.4",
     "vitest-environment-miniflare": "^2.14.4",
+    "eventsource": "^2.0.1",
     "webpack": "^5.95.0",
     "webpack-http-server": "^0.5.0"
   },
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index ac9c27ee..53af1df7 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -153,6 +153,9 @@ importers:
       eslint-plugin-prettier:
         specifier: ^5.5.4
         version: 5.5.4(@types/eslint@8.56.7)(eslint-config-prettier@10.1.8(eslint@9.34.0(jiti@2.4.2)))(eslint@9.34.0(jiti@2.4.2))(prettier@3.6.2)
+      eventsource:
+        specifier: ^2.0.1
+        version: 2.0.2
       express:
         specifier: ^5.0.0
         version: 5.0.1
@@ -2702,6 +2705,10 @@ packages:
     resolution: {integrity: sha512-mQw+2fkQbALzQ7V0MY0IqdnXNOeTtP4r0lN9z7AAawCXgqea7bDii20AYrIBrFd/Hx0M2Ocz6S111CaFkUcb0Q==}
     engines: {node: '>=0.8.x'}
 
+  eventsource@2.0.2:
+    resolution: {integrity: sha512-IzUmBGPR3+oUG9dUeXynyNmf91/3zUSJg1lCktzKw47OXuhco54U3r9B7O4XX+Rb1Itm9OZ2b0RkTs10bICOxA==}
+    engines: {node: '>=12.0.0'}
+
   execa@5.1.1:
     resolution: {integrity: sha512-8uSpZZocAZRBAPIEINJj3Lo9HyGitllczc27Eh5YYojjMFMn8yHMDMaUHE2Jqfq05D/wucwI4JGURyXt1vchyg==}
     engines: {node: '>=10'}
@@ -8021,6 +8028,8 @@ snapshots:
 
   events@3.3.0: {}
 
+  eventsource@2.0.2: {}
+
   execa@5.1.1:
     dependencies:
       cross-spawn: 7.0.3
diff --git a/test.sh b/test.sh
index 235323a5..9a2dfbf6 100755
--- a/test.sh
+++ b/test.sh
@@ -14,8 +14,8 @@ echo "Running tests (mode: ${MODE})"
 if [ "${MODE}" = "base" ]; then
   echo "Running base tests"
   pnpm -s build
-  pnpm -s vitest --run
-  pnpm -s vitest --run --config=./test/node/vitest.config.ts
+  pnpm -s vitest --run --exclude="test/experimental/**"
+  pnpm -s vitest --run --config=./test/node/vitest.config.ts --exclude="test/experimental/**"
   exit 0
 fi
 
diff --git a/test/experimental/setup-eventsource.ts b/test/experimental/setup-eventsource.ts
index a44c141e..f7292ac5 100644
--- a/test/experimental/setup-eventsource.ts
+++ b/test/experimental/setup-eventsource.ts
@@ -1,11 +1,3 @@
 import EventSource from 'eventsource'
-;(global as any).EventSource = EventSource
-export {} // Polyfill EventSource in Node for tests that rely on the browser EventSource API.
-// Uses the `eventsource` package to provide a minimal compatible class.
-// This file is loaded by Vitest via `setupFiles` before tests run.
-import EventSource from 'eventsource'
-
-// Some implementations expect `EventSource` to be available globally.
-;(global as any).EventSource = EventSource
-
+(global as any).EventSource = EventSource
 export {}
diff --git a/test/experimental/sse/sse-cleanup.node.test.ts b/test/experimental/sse/sse-cleanup.node.test.ts
index c125f4af..0177a97a 100644
--- a/test/experimental/sse/sse-cleanup.node.test.ts
+++ b/test/experimental/sse/sse-cleanup.node.test.ts
@@ -1,95 +1,88 @@
+
 import { setupServer } from 'msw/node'
 import { sse } from 'msw'
 import { test, expect, vi } from 'vitest'
 
 function wait(ms: number) {
-  return new Promise((res) => setTimeout(res, ms))
+	return new Promise((res) => setTimeout(res, ms))
 }
 
 test('does not log events from closed SSE connections (node)', async () => {
-  const captured: string[] = []
-  const timers: any[] = []
-  const timeouts: any[] = []
-
-  vi.spyOn(console, 'groupCollapsed').mockImplementation((...args: any[]) => {
-    try {
-      captured.push(String(args[0]))
-    } catch {
-      captured.push('[groupCollapsed]')
-    }
-  })
-  vi.spyOn(console, 'log').mockImplementation((...args: any[]) => {
-    try {
-      captured.push(JSON.stringify(args))
-    } catch {
-      captured.push('[log]')
-    }
-  })
-
-  const server = setupServer()
-
-  server.listen()
-
-  try {
-    server.use(
-      sse('http://localhost/stream', ({ client }) => {
-        let count = 0
-        const timer = setInterval(() => {
-          client.send({ data: { clientId: 'A', n: ++count } })
-        }, 10)
-        timers.push(timer)
-
-        const closeTimeout = setTimeout(() => {
-          client.close()
-          clearInterval(timer)
-        }, 50)
-        timeouts.push(closeTimeout)
-      }),
-    )
-
-    void fetch('http://localhost/stream', {
-      headers: { accept: 'text/event-stream' },
-    }).catch(() => void 0)
-
-    await wait(120)
-
-    server.use(
-      sse('http://localhost/stream', ({ client }) => {
-        let count = 0
-        const timer = setInterval(() => {
-          client.send({ data: { clientId: 'B', n: ++count } })
-        }, 10)
-        timers.push(timer)
-
-        const closeTimeout = setTimeout(() => {
-          client.close()
-          clearInterval(timer)
-        }, 50)
-        timeouts.push(closeTimeout)
-      }),
-    )
-
-    void fetch('http://localhost/stream', {
-      headers: { accept: 'text/event-stream' },
-    }).catch(() => void 0)
-
-    await wait(120)
-
-    const logs = captured.join('\n')
-    const sawB = /"clientId":"B"|B/.test(logs)
-    const sawA = /"clientId":"A"|A/.test(logs)
-
-    expect(sawB).toBe(true)
-    expect(sawA).toBe(false)
-  } finally {
-    try {
-      for (const t of timers) clearInterval(t)
-      for (const t of timeouts) clearTimeout(t)
-    } catch {
-      void 0
-    }
-
-    server.close()
-    vi.restoreAllMocks()
-  }
+	const captured: string[] = []
+	const timers: any[] = []
+	const timeouts: any[] = []
+
+	vi.spyOn(console, 'log').mockImplementation((...args: any[]) => {
+		try {
+			captured.push(JSON.stringify(args))
+		} catch {
+			captured.push('[log]')
+		}
+	})
+
+	const server = setupServer()
+	server.listen()
+
+	try {
+		server.use(
+			sse('http://localhost/stream', ({ client }) => {
+				let count = 0
+				const timer = setInterval(() => {
+					client.send({ data: { clientId: 'A', n: ++count } })
+				}, 10)
+				timers.push(timer)
+				const closeTimeout = setTimeout(() => {
+					client.close()
+					clearInterval(timer)
+				}, 50)
+				timeouts.push(closeTimeout)
+			}),
+		)
+		void fetch('http://localhost/stream', {
+			headers: { accept: 'text/event-stream' },
+		}).catch(() => void 0)
+		await wait(120)
+
+		server.use(
+			sse('http://localhost/stream', ({ client }) => {
+				let count = 0
+				const timer = setInterval(() => {
+					client.send({ data: { clientId: 'B', n: ++count } })
+				}, 10)
+				timers.push(timer)
+				const closeTimeout = setTimeout(() => {
+					client.close()
+					clearInterval(timer)
+				}, 50)
+				timeouts.push(closeTimeout)
+			}),
+		)
+		void fetch('http://localhost/stream', {
+			headers: { accept: 'text/event-stream' },
+		}).catch(() => void 0)
+		await wait(120)
+
+		// Parse logs for exact clientId matches
+		const logs = captured.map(line => {
+			try {
+				return JSON.parse(line)
+			} catch {
+				return null
+			}
+		}).filter(Boolean)
+		const sawB = logs.some(args => args[0]?.data?.clientId === 'B')
+		const sawA = logs.some(args => args[0]?.data?.clientId === 'A')
+
+		expect(sawB).toBe(true)
+		expect(sawA).toBe(false)
+	} finally {
+		try {
+			for (const t of timers) clearInterval(t)
+			for (const t of timeouts) clearTimeout(t)
+		} catch {
+			void 0
+		}
+		server.close()
+		vi.restoreAllMocks()
+	}
 })
diff --git a/test/experimental/sse/sse-cleanup.test.ts b/test/experimental/sse/sse-cleanup.test.ts
index 60257705..db17985d 100644
--- a/test/experimental/sse/sse-cleanup.test.ts
+++ b/test/experimental/sse/sse-cleanup.test.ts
@@ -1,96 +1,91 @@
 import { setupServer } from 'msw/node'
 import { sse } from 'msw'
-import { test, expect, vi } from 'vitest'
-
-function wait(ms: number) {
-  return new Promise((res) => setTimeout(res, ms))
-}
+import { test, expect } from 'vitest'
 
 test('does not log events from closed SSE connections', async () => {
-  const captured: string[] = []
-  const timers: any[] = []
-  const timeouts: any[] = []
-
-  vi.spyOn(console, 'groupCollapsed').mockImplementation((...args: any[]) => {
-    try {
-      captured.push(String(args[0]))
-    } catch {
-      captured.push('[groupCollapsed]')
+  const received: any[] = []
+  // First handler: sends A events
+  let server = setupServer(
+    sse('http://localhost/stream', ({ client }) => {
+      let count = 0
+      const timer = setInterval(() => {
+        client.send({ data: { clientId: 'A', n: ++count } })
+      }, 10)
+      setTimeout(() => {
+        client.close()
+        clearInterval(timer)
+      }, 50)
+    })
+  )
+  server.listen()
+  try {
+    const esA = new EventSource('http://localhost/stream')
+    esA.onmessage = e => {
+      received.push(JSON.parse(e.data))
     }
-  })
-  vi.spyOn(console, 'log').mockImplementation((...args: any[]) => {
-    try {
-      captured.push(JSON.stringify(args))
-    } catch {
-      captured.push('[log]')
+    esA.onerror = () => {
+      esA.close()
     }
-  })
 
-  const server = setupServer()
+    // Wait for A to close
+    await new Promise(resolve => {
+      esA.addEventListener('error', () => resolve(undefined))
+    })
+    server.close()
+  } finally {
+    server.close()
+  }
 
+  // Second handler: sends B events
+  server = setupServer(
+    sse('http://localhost/stream', ({ client }) => {
+      let count = 0
+      const timer = setInterval(() => {
+        client.send({ data: { clientId: 'B', n: ++count } })
+      }, 10)
+      setTimeout(() => {
+        client.close()
+        clearInterval(timer)
+      }, 50)
+    })
+  )
   server.listen()
-
   try {
-    server.use(
-      sse('http://localhost/stream', ({ client }) => {
-        let count = 0
-        const timer = setInterval(() => {
-          client.send({ data: { clientId: 'A', n: ++count } })
-        }, 10)
-        timers.push(timer)
-
-        const closeTimeout = setTimeout(() => {
-          client.close()
-          clearInterval(timer)
-        }, 50)
-        timeouts.push(closeTimeout)
-      }),
-    )
-
-    void fetch('http://localhost/stream', {
-      headers: { accept: 'text/event-stream' },
-    }).catch(() => void 0)
-
-    await wait(120)
-
-    server.use(
-      sse('http://localhost/stream', ({ client }) => {
-        let count = 0
-        const timer = setInterval(() => {
-          client.send({ data: { clientId: 'B', n: ++count } })
-        }, 10)
-        timers.push(timer)
-
-        const closeTimeout = setTimeout(() => {
-          client.close()
-          clearInterval(timer)
-        }, 50)
-        timeouts.push(closeTimeout)
-      }),
-    )
-
-    void fetch('http://localhost/stream', {
-      headers: { accept: 'text/event-stream' },
-    }).catch(() => void 0)
-
-    await wait(120)
-
-    const logs = captured.join('\n')
+    const esB = new EventSource('http://localhost/stream')
+    esB.onmessage = e => {
+      received.push(JSON.parse(e.data))
+    }
+    esB.onerror = () => {
+      esB.close()
+    }
 
-    const sawB = /"clientId":"B"|B/.test(logs)
-    const sawA = /"clientId":"A"|A/.test(logs)
+    // Wait for at least one B event, but fail with assertion if not received in 2s
+    let gotB = false
+    await new Promise((resolve, reject) => {
+      const timeout = setTimeout(() => {
+        reject(new Error('No B event received'))
+      }, 2000)
+      const check = () => {
+        if (received.some(ev => ev.clientId === 'B')) {
+          gotB = true
+          clearTimeout(timeout)
+          resolve(undefined)
+        } else {
+          setTimeout(check, 10)
+        }
+      }
+      check()
+    }).catch((err) => {
+      expect(gotB).toBe(true) // This will always fail if no B event
+    })
+
+    // Only check received events after B
+    const sawB = received.some(ev => ev.clientId === 'B')
+    const sawA = received.some(ev => ev.clientId === 'A' && sawB)
 
     expect(sawB).toBe(true)
     expect(sawA).toBe(false)
   } finally {
-    try {
-      for (const t of timers) clearInterval(t)
-      for (const t of timeouts) clearTimeout(t)
-    } catch {
-      void 0
-    }
-
     server.close()
-    vi.restoreAllMocks()
   }
 })
