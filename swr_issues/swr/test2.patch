diff --git a/test.sh b/test.sh
new file mode 100755
index 0000000..27c1666
--- /dev/null
+++ b/test.sh
@@ -0,0 +1,53 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+NEW_TEST_FILE="test/use-swr-mutation-optimistic.test.tsx"
+
+
+# 1. NEW_TEST_FILE: Excluded during 'base' mode.
+# 2. EXCLUDED BASELINE TESTS: Omitted to bypass already failing baseline tests due to environmental instability.
+# 3. e2e/: Excludes the end-to-end directory.
+EXCLUDE_TESTS=(
+  "${NEW_TEST_FILE}"
+  "test/use-swr-focus.test.tsx"
+  "test/use-swr-subscription.test.tsx"
+  "test/use-swr-infinite.test.tsx"
+  "e2e/"
+)
+
+
+IFS="|"
+IGNORE_PATTERNS="${EXCLUDE_TESTS[*]}"
+
+IFS=$' \t\n'
+
+
+if [ "$#" -ge 1 ]; then
+  MODE="$1"
+elif [ "${MODE-""}" != "" ]; then
+  MODE="$MODE"
+else
+  MODE=base
+fi
+
+echo " Running SWR tests (mode: ${MODE})"
+echo "---"
+
+
+
+if [ "${MODE}" = "base" ]; then
+  echo "Running BASE tests (All original tests, excluding known unstable files)"
+  pnpm test --no-watch \
+    --testPathIgnorePatterns="${IGNORE_PATTERNS}"
+  exit 0
+fi
+
+if [ "${MODE}" = "new" ]; then
+  echo "Running NEW tests"
+
+  pnpm test --verbose "${NEW_TEST_FILE}"
+  exit 0
+fi
+
+echo "Unknown MODE: ${MODE}. Use 'base' (default) or 'new'."
+exit 2
diff --git a/test/use-swr-mutation-optimistic.test.tsx b/test/use-swr-mutation-optimistic.test.tsx
new file mode 100644
index 0000000..cd6a456
--- /dev/null
+++ b/test/use-swr-mutation-optimistic.test.tsx
@@ -0,0 +1,153 @@
+import { render, screen, fireEvent, act } from '@testing-library/react'
+import useSWRMutation from '../src/mutation/index'
+import { SWRConfig } from '../src/index'
+import { sleep } from './utils'
+
+describe('useSWRMutation - Optimistic Data State', () => {
+  it('should update "data" optimistically immediately', async () => {
+    const fetcher = async () => {
+      await sleep(100)
+      return 'server'
+    }
+    function Page() {
+      const { trigger, data } = useSWRMutation('key-1', fetcher, { optimisticData: 'optimistic' })
+      return (
+        <button data-testid="btn" onClick={() => trigger()}>{data || 'undefined'}</button>
+      )
+    }
+    render(
+      <SWRConfig value={{ provider: () => new Map() }}>
+        <Page />
+      </SWRConfig>
+    )
+    const btn = screen.getByTestId('btn')
+    expect(btn.textContent).toBe('undefined')
+    fireEvent.click(btn)
+    expect(btn.textContent).toBe('optimistic')
+    await act(() => sleep(150))
+    expect(btn.textContent).toBe('server')
+  })
+
+  it('should prioritize optimisticData passed to trigger over hook config', async () => {
+    const fetcher = async () => {
+      await sleep(100)
+      return 'server'
+    }
+    function Page() {
+      const { trigger, data } = useSWRMutation('key-2', fetcher, { optimisticData: 'hook-level' })
+      return (
+        <button data-testid="btn" onClick={() => trigger(undefined, { optimisticData: 'trigger-level' })}>
+          {data || 'undefined'}
+        </button>
+      )
+    }
+    render(
+      <SWRConfig value={{ provider: () => new Map() }}>
+        <Page />
+      </SWRConfig>
+    )
+    const btn = screen.getByTestId('btn')
+    fireEvent.click(btn)
+    expect(btn.textContent).toBe('trigger-level')
+  })
+
+  it('should rollback "data" to the previous value on failure', async () => {
+    const fetcher = async () => {
+      await sleep(50)
+      throw new Error('fetch-failed')
+    }
+
+    function Page() {
+      const { trigger, data, error } = useSWRMutation('key-3', fetcher, {
+        optimisticData: 'optimistic-val',
+        throwOnError: false,
+        rollbackOnError: true
+      })
+      return (
+        <div data-testid="container">
+          <button onClick={() => trigger()}>trigger</button>
+          <span data-testid="data">{data || 'undefined'}</span>
+          <span data-testid="error">{error ? 'error' : 'no-error'}</span>
+        </div>
+      )
+    }
+
+    render(
+      <SWRConfig value={{ fallback: { 'key-3': 'initial' }, provider: () => new Map() }}>
+        <Page />
+      </SWRConfig>
+    )
+
+    const triggerBtn = screen.getByText('trigger')
+    const dataSpan = screen.getByTestId('data')
+
+    expect(dataSpan.textContent).toBe('initial')
+
+    fireEvent.click(triggerBtn)
+    expect(dataSpan.textContent).toBe('optimistic-val')
+
+    await act(() => sleep(100))
+    expect(screen.getByTestId('error').textContent).toBe('error')
+    expect(dataSpan.textContent).toBe('initial')
+  })
+
+  it('should respect trigger-level rollbackOnError and throwOnError options', async () => {
+    const fetcher = async () => {
+      await sleep(50)
+      throw new Error('fetch-failed')
+    }
+
+    let triggerPromise: Promise<any> | undefined
+
+    function Page() {
+
+      const { trigger, data, error } = useSWRMutation('key-4', fetcher, {
+        optimisticData: 'hook-optimistic',
+        rollbackOnError: true,
+        throwOnError: true
+      })
+      return (
+        <div data-testid="container">
+          <button onClick={() => {
+
+            triggerPromise = trigger(undefined, {
+
+              rollbackOnError: false,
+              throwOnError: false
+            })
+          }}>trigger</button>
+          <span data-testid="data">{data || 'undefined'}</span>
+          <span data-testid="error">{error ? 'error' : 'no-error'}</span>
+        </div>
+      )
+    }
+
+    render(
+      <SWRConfig value={{ fallback: { 'key-4': 'initial' }, provider: () => new Map() }}>
+        <Page />
+      </SWRConfig>
+    )
+
+    const triggerBtn = screen.getByText('trigger')
+    const dataSpan = screen.getByTestId('data')
+
+
+    expect(dataSpan.textContent).toBe('initial')
+
+
+    fireEvent.click(triggerBtn)
+    expect(dataSpan.textContent).toBe('hook-optimistic')
+
+
+    await act(() => sleep(100))
+
+
+    await expect(triggerPromise).resolves.toBeUndefined()
+
+
+    expect(screen.getByTestId('error').textContent).toBe('error')
+
+
+    expect(dataSpan.textContent).toBe('hook-optimistic')
+  })
+})
