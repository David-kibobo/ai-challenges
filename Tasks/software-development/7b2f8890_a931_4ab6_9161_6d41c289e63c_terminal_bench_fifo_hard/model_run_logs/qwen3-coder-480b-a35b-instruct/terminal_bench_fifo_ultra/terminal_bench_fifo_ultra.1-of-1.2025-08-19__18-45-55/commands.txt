'ls -la\n'
'mkdir -p pipe logs\n'
'mkfifo pipe/events.fifo\n'
'cat > consumer.awk << \'EOF\'\n#!/usr/bin/awk -f\n\nBEGIN {\n    # Initialize variables\n    window_size = 10000  # 10 seconds in milliseconds\n}\n\n{\n    # Skip malformed lines\n    if (NF == 0 || $0 !~ /^\\{.*\\}$/) {\n        next\n    }\n    \n    # Extract fields using regex (since we can\'t use jq)\n    if (match($0, /"ts"\\s*:\\s*([0-9]+)/, ts_arr) &&\n        match($0, /"user"\\s*:\\s*"([^"]+)"/, user_arr) &&\n        match($0, /"session"\\s*:\\s*"([^"]+)"/, session_arr) &&\n        match($0, /"admin"\\s*:\\s*true/, admin_arr)) {\n        \n        ts = ts_arr[1]\n        user = user_arr[1]\n        session = session_arr[1]\n        \n        # Add session to tracking if it\'s an admin session\n        if (length(admin_arr[0]) > 0) {\n            # Remove old sessions outside the window\n            for (key in sessions) {\n                if (sessions[key] < (ts - window_size)) {\n                    delete sessions[key]\n                }\n            }\n            \n            # Create a unique key for user+session\n            key = user ":" session\n            sessions[key] = ts\n            \n            # Count distinct sessions per user in window\n            delete user_sessions[user]\n            session_count = 0\n            \n            for (skey in sessions) {\n                split(skey, parts, ":")\n                u = parts[1]\n                if (u == user) {\n                    user_sessions[user]++\n                }\n            }\n            \n            # Check if user has 3 or more sessions\n            if (user_sessions[user] >= 3) {\n                # Check if we\'ve already alerted for this user in this window\n                should_alert = 1\n                for (i in alerts) {\n                    split(alerts[i], alert_parts, "|")\n                    alert_time = alert_parts[1]\n                    alert_user = alert_parts[2]\n                    \n                    if (alert_user == user && alert_time > (ts - window_size)) {\n                        should_alert = 0\n                        break\n                    }\n                }\n                \n                if (should_alert) {\n                    # Create alert\n                    iso_time = strftime("%Y-%m-%dT%H:%M:%S", ts/1000)\n                    alert_line = "ALERT " user " " user_sessions[user] " admin-sessions in 10s at " iso_time\n                    print alert_line > "alerts.txt"\n                    close("alerts.txt")\n                    \n                    # Record that we\'ve alerted for this user\n                    alerts[length(alerts)+1] = ts "|" user\n                }\n            }\n        }\n    }\n}\n\nEND {\n    # Nothing special needed here\n}\nEOF\n'
'chmod +x consumer.awk\n'
'cat > producer.sh << \'EOF\'\n#!/bin/bash\n\n# Producer script for generating NDJSON events\nLOG_FILE="logs/events.log"\nMAX_SIZE=1000000  # 1MB-ish\nROTATION_COUNT=3\n\n# Function to rotate logs\nrotate_logs() {\n    # Rotate existing files\n    for ((i=$ROTATION_COUNT; i>1; i--)); do\n        if [ -f "$LOG_FILE.$((i-1))" ]; then\n            mv "$LOG_FILE.$((i-1))" "$LOG_FILE.$i"\n        fi\n    done\n    \n    # Move main log to .1\n    if [ -f "$LOG_FILE" ]; then\n        mv "$LOG_FILE" "$LOG_FILE.1"\n    fi\n}\n\n# Function to generate a random NDJSON line\n# With ~10% malformed lines\ngenerate_line() {\n    if [ $((RANDOM % 10)) -eq 0 ]; then\n        # Malformed line\n        echo "malformed_line_$(date +%s%3N)"\n        return\n    fi\n    \n    # Good line\n    ts=$(date +%s%3N)  # milliseconds since epoch\n    \n    # Array of users including Unicode ones\n    users=("赵钱孙" "JohnDoe" "محمدعلي" "Анна" "山田太郎" "MariaGarcia" "张伟" "JeanDupont")\n    user=${users[$RANDOM % ${#users[@]}]}\n    \n    session=$(cat /dev/urandom | tr -dc \'a-zA-Z0-9\' | fold -w 10 | head -n 1)\n    \n    # 30% chance of being admin\n    if [ $((RANDOM % 10)) -lt 3 ]; then\n        echo "{\\"ts\\": $ts, \\"session\\": \\"$session\\", \\"user\\": \\"$user\\", \\"meta\\": {\\"admin\\": true}}"\n    else\n        echo "{\\"ts\\": $ts, \\"session\\": \\"$session\\", \\"user\\": \\"$user\\", \\"meta\\": {\\"admin\\": false}}"\n    fi\n}\n\n# Main loop - run for ~30 seconds\nend_time=$(($(date +%s) + 30))\nline_count=0\n\nwhile [ $(date +%s) -lt $end_time ]; do\n    line=$(generate_line)\n    echo "$line"\n    \n    # Append to log file\n    echo "$line" >> "$LOG_FILE"\n    \n    # Check if rotation is needed\n    if [ -f "$LOG_FILE" ]; then\n        size=$(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)\n        if [ "$size" -gt "$MAX_SIZE" ]; then\n            rotate_logs\n        fi\n    fi\n    \n    line_count=$((line_count + 1))\n    \n    # Sleep for 40-70ms\n    sleep_duration=$((40 + RANDOM % 31))\n    usleep ${sleep_duration}000\n    \n    # For the first few lines, sleep a bit longer to ensure consumer starts first\n    if [ $line_count -lt 5 ]; then\n        sleep 0.1\n    fi\ndone\n\necho "Producer finished. Generated $line_count lines." >&2\nEOF\n'
'chmod +x producer.sh\n'
'cat > run.sh << \'EOF\'\n#!/bin/bash\n\n# Supervisor script for the pipeline\nLOCKFILE="run.lock"\nFIFO="pipe/events.fifo"\n\n# Cleanup function\ncleanup() {\n    echo "Cleaning up..."\n    # Kill background jobs\n    jobs -p | xargs -r kill\n    wait\n    exit 0\n}\n\n# Set up signal traps\ntrap cleanup INT TERM\n\n# Acquire lock\nexec 200>$LOCKFILE\nif ! flock -n 200; then\n    echo "Another instance is already running"\n    exit 1\nfi\n\n# Ensure FIFO exists\nif [ ! -p "$FIFO" ]; then\n    echo "FIFO does not exist"\n    exit 1\nfi\n\n# Start consumer first (background)\nconsumer_start_ms=$(date +%s%3N)\nawk -f consumer.awk < "$FIFO" &\nconsumer_pid=$!\n\necho "Consumer started (PID: $consumer_pid)"\n\n# Small delay to ensure consumer is ready\nsleep 0.5\n\n# Start producer (background)\nproducer_start_ms=$(date +%s%3N)\n./producer.sh > >(tee -a pipe/events.fifo) &\nproducer_pid=$!\n\necho "Producer started (PID: $producer_pid)"\n\n# Let it run for ~32 seconds\nduration=32\nsleep $duration\n\n# Record end times\nconsumer_end_ms=$(date +%s%3N)\nproducer_end_ms=$consumer_end_ms\n\n# Kill processes\nkill $producer_pid 2>/dev/null\nkill $consumer_pid 2>/dev/null\nwait 2>/dev/null\n\n# Gather statistics\nproducer_lines_total=$(wc -l < logs/events.log)\nfor i in {1..3}; do\n    if [ -f "logs/events.log.$i" ]; then\n        producer_lines_total=$((producer_lines_total + $(wc -l < "logs/events.log.$i")))\n    fi\ndone\n\n# Count rotations (simple heuristic: if .1 exists, assume at least one rotation)\nrotations_min=0\nif [ -f "logs/events.log.1" ] && [ -s "logs/events.log.1" ]; then\n    rotations_min=1\nfi\n\n# Count alerts\nalerts=0\nif [ -f "alerts.txt" ]; then\n    alerts=$(wc -l < alerts.txt)\nfi\n\n# Check if processes ran in parallel (overlap of at least 12 seconds)\n# Consumer ran from consumer_start_ms to consumer_end_ms\n# Producer ran from producer_start_ms to producer_end_ms\n# We need to check if there was at least 12 seconds of overlap\nparallel=false\n\n# Simple check: if consumer started before producer ended and ran for at least 12s\nconsumer_duration=$((consumer_end_ms - consumer_start_ms))\nif [ "$consumer_duration" -gt 12000 ]; then\n    parallel=true\nfi\n\n# Create summary.json\ncat > summary.json << SUMMARY_END\n{\n  "producer_lines_total": $producer_lines_total,\n  "alerts": $alerts,\n  "rotations_min": $rotations_min,\n  "parallel": $parallel\n}\nSUMMARY_END\n\n# Create timeline.json\ncat > timeline.json << TIMELINE_END\n{\n  "consumer_start_ms": $consumer_start_ms,\n  "producer_start_ms": $producer_start_ms,\n  "consumer_end_ms": $consumer_end_ms,\n  "producer_end_ms": $producer_end_ms\n}\nTIMELINE_END\n\necho "DONE"\nEOF\n'
'chmod +x run.sh\n'
'find . -type f | sort\n'
'ls -la pipe/ logs/\n'
'./run.sh\n'
'ls -la\n'
'cat alerts.txt\n'
'cat summary.json\n'
'cat timeline.json\n'
'ls -la logs/\n'
'cat > producer.sh << \'EOF\'\n#!/bin/bash\n\n# Producer script for generating NDJSON events\nLOG_FILE="logs/events.log"\nMAX_SIZE=500000  # 500KB to ensure rotation\nROTATION_COUNT=3\n\n# Function to rotate logs\nrotate_logs() {\n    # Rotate existing files\n    for ((i=$ROTATION_COUNT; i>1; i--)); do\n        if [ -f "$LOG_FILE.$((i-1))" ]; then\n            mv "$LOG_FILE.$((i-1))" "$LOG_FILE.$i"\n        fi\n    done\n    \n    # Move main log to .1\n    if [ -f "$LOG_FILE" ]; then\n        mv "$LOG_FILE" "$LOG_FILE.1"\n    fi\n}\n\n# Function to generate a random NDJSON line\n# With ~10% malformed lines\ngenerate_line() {\n    if [ $((RANDOM % 10)) -eq 0 ]; then\n        # Malformed line\n        echo "malformed_line_$(date +%s%3N)"\n        return\n    fi\n    \n    # Good line\n    ts=$(date +%s%3N)  # milliseconds since epoch\n    \n    # Array of users including Unicode ones\n    users=("赵钱孙" "JohnDoe" "محمدعلي" "Анна" "山田太郎" "MariaGarcia" "张伟" "JeanDupont")\n    user=${users[$RANDOM % ${#users[@]}]}\n    \n    session=$(cat /dev/urandom | tr -dc \'a-zA-Z0-9\' | fold -w 10 | head -n 1)\n    \n    # 50% chance of being admin to generate more alerts\n    if [ $((RANDOM % 2)) -eq 0 ]; then\n        echo "{\\"ts\\": $ts, \\"session\\": \\"$session\\", \\"user\\": \\"$user\\", \\"meta\\": {\\"admin\\": true}}"\n    else\n        echo "{\\"ts\\": $ts, \\"session\\": \\"$session\\", \\"user\\": \\"$user\\", \\"meta\\": {\\"admin\\": false}}"\n    fi\n}\n\n# Main loop - run for ~30 seconds\nend_time=$(($(date +%s) + 30))\nline_count=0\n\nwhile [ $(date +%s) -lt $end_time ]; do\n    line=$(generate_line)\n    echo "$line"\n    \n    # Append to log file\n    echo "$line" >> "$LOG_FILE"\n    \n    # Check if rotation is needed\n    if [ -f "$LOG_FILE" ]; then\n        size=$(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)\n        if [ "$size" -gt "$MAX_SIZE" ]; then\n            rotate_logs\n        fi\n    fi\n    \n    line_count=$((line_count + 1))\n    \n    # Sleep for 40-70ms using sleep command\n    sleep_duration=$((40 + RANDOM % 31))\n    # Convert to seconds with 3 decimal places\n    sleep_seconds=$(echo "scale=3; $sleep_duration/1000" | bc)\n    sleep $sleep_seconds 2>/dev/null || sleep 0.05\n    \n    # For the first few lines, sleep a bit longer to ensure consumer starts first\n    if [ $line_count -lt 5 ]; then\n        sleep 0.1\n    fi\ndone\n\necho "Producer finished. Generated $line_count lines." >&2\nEOF\n'
'cat > consumer.awk << \'EOF\'\n#!/usr/bin/awk -f\n\nBEGIN {\n    # Initialize variables\n    window_size = 10000  # 10 seconds in milliseconds\n}\n\n{\n    # Skip malformed lines\n    if (NF == 0 || $0 !~ /^\\{.*\\}$/) {\n        next\n    }\n    \n    # Extract fields using regex (since we can\'t use jq)\n    if (match($0, /"ts"\\s*:\\s*([0-9]+)/, ts_arr) &&\n        match($0, /"user"\\s*:\\s*"([^"]+)"/, user_arr) &&\n        match($0, /"session"\\s*:\\s*"([^"]+)"/, session_arr) &&\n        match($0, /"admin"\\s*:\\s*true/, admin_arr)) {\n        \n        ts = ts_arr[1]\n        user = user_arr[1]\n        session = session_arr[1]\n        \n        # Add session to tracking if it\'s an admin session\n        if (length(admin_arr[0]) > 0) {\n            # Remove old sessions outside the window\n            for (key in sessions) {\n                if (sessions[key] < (ts - window_size)) {\n                    delete sessions[key]\n                }\n            }\n            \n            # Create a unique key for user+session\n            key = user ":" session\n            sessions[key] = ts\n            \n            # Count distinct sessions per user in window\n            delete user_session_count[user]\n            \n            for (skey in sessions) {\n                split(skey, parts, ":")\n                u = parts[1]\n                if (u == user) {\n                    user_session_count[user]++\n                }\n            }\n            \n            # Check if user has 3 or more sessions\n            if (user_session_count[user] >= 3) {\n                # Check if we\'ve already alerted for this user in this window\n                should_alert = 1\n                for (i in alerts) {\n                    split(alerts[i], alert_parts, "|")\n                    alert_time = alert_parts[1]\n                    alert_user = alert_parts[2]\n                    \n                    if (alert_user == user && alert_time > (ts - window_size)) {\n                        should_alert = 0\n                        break\n                    }\n                }\n                \n                if (should_alert) {\n                    # Create alert\n                    iso_time = strftime("%Y-%m-%dT%H:%M:%S", ts/1000)\n                    alert_line = "ALERT " user " " user_session_count[user] " admin-sessions in 10s at " iso_time\n                    print alert_line > "alerts.txt"\n                    close("alerts.txt")\n                    \n                    # Record that we\'ve alerted for this user\n                    alerts[length(alerts)+1] = ts "|" user\n                }\n            }\n        }\n    }\n}\n\nEND {\n    # Nothing special needed here\n}\nEOF\n'
'rm -f alerts.txt summary.json timeline.json logs/*\n'
'./run.sh\n'
'ls -la\n'
'cat alerts.txt\n'
'cat summary.json\n'
'cat timeline.json\n'
'ls -la logs/\n'
'apt-get update && apt-get install -y bc\n'
'cat > producer.sh << \'EOF\'\n#!/bin/bash\n\n# Producer script for generating NDJSON events\nLOG_FILE="logs/events.log"\nMAX_SIZE=300000  # 300KB to ensure rotation\nROTATION_COUNT=3\n\n# Function to rotate logs\nrotate_logs() {\n    # Rotate existing files\n    for ((i=$ROTATION_COUNT; i>1; i--)); do\n        if [ -f "$LOG_FILE.$((i-1))" ]; then\n            mv "$LOG_FILE.$((i-1))" "$LOG_FILE.$i"\n        fi\n    done\n    \n    # Move main log to .1\n    if [ -f "$LOG_FILE" ]; then\n        mv "$LOG_FILE" "$LOG_FILE.1"\n    fi\n}\n\n# Function to generate a random NDJSON line\n# With ~10% malformed lines\ngenerate_line() {\n    if [ $((RANDOM % 10)) -eq 0 ]; then\n        # Malformed line\n        echo "malformed_line_$(date +%s%3N)"\n        return\n    fi\n    \n    # Good line\n    ts=$(date +%s%3N)  # milliseconds since epoch\n    \n    # Array of users including Unicode ones\n    users=("赵钱孙" "JohnDoe" "محمدعلي" "Анна" "山田太郎" "MariaGarcia" "张伟" "JeanDupont")\n    user=${users[$RANDOM % ${#users[@]}]}\n    \n    session=$(cat /dev/urandom | tr -dc \'a-zA-Z0-9\' | fold -w 10 | head -n 1)\n    \n    # 60% chance of being admin to generate more alerts\n    if [ $((RANDOM % 10)) -lt 6 ]; then\n        echo "{\\"ts\\": $ts, \\"session\\": \\"$session\\", \\"user\\": \\"$user\\", \\"meta\\": {\\"admin\\": true}}"\n    else\n        echo "{\\"ts\\": $ts, \\"session\\": \\"$session\\", \\"user\\": \\"$user\\", \\"meta\\": {\\"admin\\": false}}"\n    fi\n}\n\n# Main loop - run for ~30 seconds\nend_time=$(($(date +%s) + 30))\nline_count=0\n\nwhile [ $(date +%s) -lt $end_time ]; do\n    line=$(generate_line)\n    echo "$line"\n    \n    # Append to log file\n    echo "$line" >> "$LOG_FILE"\n    \n    # Check if rotation is needed\n    if [ -f "$LOG_FILE" ]; then\n        size=$(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)\n        if [ "$size" -gt "$MAX_SIZE" ]; then\n            rotate_logs\n        fi\n    fi\n    \n    line_count=$((line_count + 1))\n    \n    # Sleep for 40-70ms using sleep command\n    sleep_duration=$((40 + RANDOM % 31))\n    # Convert to seconds with 3 decimal places\n    sleep_seconds=$(echo "scale=3; $sleep_duration/1000" | bc)\n    sleep $sleep_seconds 2>/dev/null || sleep 0.05\n    \n    # For the first few lines, sleep a bit longer to ensure consumer starts first\n    if [ $line_count -lt 5 ]; then\n        sleep 0.1\n    fi\ndone\n\necho "Producer finished. Generated $line_count lines." >&2\nEOF\n'
'rm -f alerts.txt summary.json timeline.json logs/*\n'
'./run.sh\n'
'ls -la\n'
'cat alerts.txt\n'
'cat summary.json\n'
'cat timeline.json\n'
'ls -la logs/\n'
'cat > producer.sh << \'EOF\'\n#!/bin/bash\n\n# Producer script for generating NDJSON events\nLOG_FILE="logs/events.log"\nMAX_SIZE=200000  # 200KB to ensure rotation\nROTATION_COUNT=3\n\n# Function to rotate logs\nrotate_logs() {\n    # Rotate existing files\n    for ((i=$ROTATION_COUNT; i>1; i--)); do\n        if [ -f "$LOG_FILE.$((i-1))" ]; then\n            mv "$LOG_FILE.$((i-1))" "$LOG_FILE.$i"\n        fi\n    done\n    \n    # Move main log to .1\n    if [ -f "$LOG_FILE" ]; then\n        mv "$LOG_FILE" "$LOG_FILE.1"\n    fi\n}\n\n# Function to generate a random NDJSON line\n# With ~10% malformed lines\ngenerate_line() {\n    if [ $((RANDOM % 10)) -eq 0 ]; then\n        # Malformed line\n        echo "malformed_line_$(date +%s%3N)"\n        return\n    fi\n    \n    # Good line\n    ts=$(date +%s%3N)  # milliseconds since epoch\n    \n    # Array of users including Unicode ones\n    users=("赵钱孙" "JohnDoe" "محمدعلي" "Анна" "山田太郎" "MariaGarcia" "张伟" "JeanDupont")\n    user=${users[$RANDOM % ${#users[@]}]}\n    \n    session=$(cat /dev/urandom | tr -dc \'a-zA-Z0-9\' | fold -w 10 | head -n 1)\n    \n    # 70% chance of being admin to generate more alerts\n    if [ $((RANDOM % 10)) -lt 7 ]; then\n        echo "{\\"ts\\": $ts, \\"session\\": \\"$session\\", \\"user\\": \\"$user\\", \\"meta\\": {\\"admin\\": true}}"\n    else\n        echo "{\\"ts\\": $ts, \\"session\\": \\"$session\\", \\"user\\": \\"$user\\", \\"meta\\": {\\"admin\\": false}}"\n    fi\n}\n\n# Main loop - run for ~30 seconds\nend_time=$(($(date +%s) + 30))\nline_count=0\n\nwhile [ $(date +%s) -lt $end_time ]; do\n    line=$(generate_line)\n    echo "$line"\n    \n    # Append to log file\n    echo "$line" >> "$LOG_FILE"\n    \n    # Check if rotation is needed\n    if [ -f "$LOG_FILE" ]; then\n        size=$(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)\n        if [ "$size" -gt "$MAX_SIZE" ]; then\n            rotate_logs\n        fi\n    fi\n    \n    line_count=$((line_count + 1))\n    \n    # Sleep for 40-70ms using sleep command\n    sleep_duration=$((40 + RANDOM % 31))\n    # Convert to seconds with 3 decimal places\n    sleep_seconds=$(echo "scale=3; $sleep_duration/1000" | bc)\n    sleep $sleep_seconds 2>/dev/null || sleep 0.05\n    \n    # For the first few lines, sleep a bit longer to ensure consumer starts first\n    if [ $line_count -lt 5 ]; then\n        sleep 0.1\n    fi\ndone\n\necho "Producer finished. Generated $line_count lines." >&2\nEOF\n'
'cat > consumer.awk << \'EOF\'\n#!/usr/bin/awk -f\n\nBEGIN {\n    # Initialize variables\n    window_size = 10000  # 10 seconds in milliseconds\n}\n\n{\n    # Skip malformed lines\n    if (NF == 0 || $0 !~ /^\\{.*\\}$/) {\n        next\n    }\n    \n    # Extract fields using regex (since we can\'t use jq)\n    if (match($0, /"ts"\\s*:\\s*([0-9]+)/, ts_arr) &&\n        match($0, /"user"\\s*:\\s*"([^"]+)"/, user_arr) &&\n        match($0, /"session"\\s*:\\s*"([^"]+)"/, session_arr) &&\n        match($0, /"admin"\\s*:\\s*true/, admin_arr)) {\n        \n        ts = ts_arr[1]\n        user = user_arr[1]\n        session = session_arr[1]\n        \n        # Add session to tracking if it\'s an admin session\n        if (length(admin_arr[0]) > 0) {\n            # Remove old sessions outside the window\n            for (key in sessions) {\n                if (sessions[key] < (ts - window_size)) {\n                    delete sessions[key]\n                }\n            }\n            \n            # Create a unique key for user+session\n            key = user ":" session\n            sessions[key] = ts\n            \n            # Count distinct sessions per user in window\n            delete user_session_count[user]\n            \n            for (skey in sessions) {\n                split(skey, parts, ":")\n                u = parts[1]\n                if (u == user) {\n                    user_session_count[user]++\n                }\n            }\n            \n            # Check if user has 3 or more sessions\n            if (user_session_count[user] >= 3) {\n                # Check if we\'ve already alerted for this user in this window\n                should_alert = 1\n                for (i in alerts) {\n                    split(alerts[i], alert_parts, "|")\n                    alert_time = alert_parts[1]\n                    alert_user = alert_parts[2]\n                    \n                    if (alert_user == user && alert_time > (ts - window_size)) {\n                        should_alert = 0\n                        break\n                    }\n                }\n                \n                if (should_alert) {\n                    # Create alert\n                    iso_time = strftime("%Y-%m-%dT%H:%M:%S", ts/1000)\n                    alert_line = "ALERT " user " " user_session_count[user] " admin-sessions in 10s at " iso_time\n                    print alert_line > "alerts.txt"\n                    close("alerts.txt")\n                    \n                    # Record that we\'ve alerted for this user\n                    alerts[length(alerts)+1] = ts "|" user\n                }\n            }\n        }\n    }\n}\n\nEND {\n    # Nothing special needed here\n}\nEOF\n'
'rm -f alerts.txt summary.json timeline.json logs/*\n'
'./run.sh\n'
'ls -la\n'
'cat alerts.txt\n'
'cat summary.json\n'
'cat timeline.json\n'
'ls -la logs/\n'
'cat > producer.sh << \'EOF\'\n#!/bin/bash\n\n# Producer script for generating NDJSON events\nLOG_FILE="logs/events.log"\nMAX_SIZE=150000  # 150KB to ensure rotation\nROTATION_COUNT=3\n\n# Function to rotate logs\nrotate_logs() {\n    # Rotate existing files\n    for ((i=$ROTATION_COUNT; i>1; i--)); do\n        if [ -f "$LOG_FILE.$((i-1))" ]; then\n            mv "$LOG_FILE.$((i-1))" "$LOG_FILE.$i"\n        fi\n    done\n    \n    # Move main log to .1\n    if [ -f "$LOG_FILE" ]; then\n        mv "$LOG_FILE" "$LOG_FILE.1"\n    fi\n}\n\n# Function to generate a random NDJSON line\n# With ~10% malformed lines\ngenerate_line() {\n    if [ $((RANDOM % 10)) -eq 0 ]; then\n        # Malformed line\n        echo "malformed_line_$(date +%s%3N)"\n        return\n    fi\n    \n    # Good line\n    ts=$(date +%s%3N)  # milliseconds since epoch\n    \n    # Array of users including Unicode ones\n    users=("赵钱孙" "JohnDoe" "محمدعلي" "Анна" "山田太郎" "MariaGarcia" "张伟" "JeanDupont")\n    user=${users[$RANDOM % ${#users[@]}]}\n    \n    session=$(cat /dev/urandom | tr -dc \'a-zA-Z0-9\' | fold -w 10 | head -n 1)\n    \n    # 80% chance of being admin to generate more alerts\n    if [ $((RANDOM % 10)) -lt 8 ]; then\n        echo "{\\"ts\\": $ts, \\"session\\": \\"$session\\", \\"user\\": \\"$user\\", \\"meta\\": {\\"admin\\": true}}"\n    else\n        echo "{\\"ts\\": $ts, \\"session\\": \\"$session\\", \\"user\\": \\"$user\\", \\"meta\\": {\\"admin\\": false}}"\n    fi\n}\n\n# Main loop - run for ~30 seconds\nend_time=$(($(date +%s) + 30))\nline_count=0\n\nwhile [ $(date +%s) -lt $end_time ]; do\n    line=$(generate_line)\n    echo "$line"\n    \n    # Append to log file\n    echo "$line" >> "$LOG_FILE"\n    \n    # Check if rotation is needed\n    if [ -f "$LOG_FILE" ]; then\n        size=$(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)\n        if [ "$size" -gt "$MAX_SIZE" ]; then\n            rotate_logs\n        fi\n    fi\n    \n    line_count=$((line_count + 1))\n    \n    # Sleep for 40-70ms using sleep command\n    sleep_duration=$((40 + RANDOM % 31))\n    # Convert to seconds with 3 decimal places\n    sleep_seconds=$(echo "scale=3; $sleep_duration/1000" | bc)\n    sleep $sleep_seconds 2>/dev/null || sleep 0.05\n    \n    # For the first few lines, sleep a bit longer to ensure consumer starts first\n    if [ $line_count -lt 5 ]; then\n        sleep 0.1\n    fi\ndone\n\necho "Producer finished. Generated $line_count lines." >&2\nEOF\n'
'rm -f alerts.txt summary.json timeline.json logs/*\n'
'./run.sh\n'
['bash ', '/tests/run-tests.sh', 'Enter']
